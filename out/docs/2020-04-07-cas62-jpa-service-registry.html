<hr>
<h2>
<a id="layout-----posttitle------apereo-cas---jpa-service-registry-w-oraclesummary----learn-how-to-manage-application-definitions-and-policies-with-cas-using-a-relational-database-such-as-oraclespublished-truetags-------cas" class="anchor" href="#layout-----posttitle------apereo-cas---jpa-service-registry-w-oraclesummary----learn-how-to-manage-application-definitions-and-policies-with-cas-using-a-relational-database-such-as-oraclespublished-truetags-------cas" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>layout:     post<br>
title:      Apereo CAS - JPA Service Registry w/ Oracle<br>
summary:    Learn how to manage application definitions and policies with CAS using a relational database such as Oracle's.<br>
published: true<br>
tags:       [CAS]</h2>
<p>An identity provider such as Apereo CAS that provides single sign-on is fully powered on once you begin to integrate and onboard applications to take advantage of centralized functionality and policy management. These applications, also known as <em>services</em> in the CAS vernacular, and their associated policies can be managed by a CAS deployment using a variety of services and technologies. The core component of the service/application management facility is what is referred to as the <em>service registry</em> that stores application definitions into an underlying store such as a relational database. Thus, the registry acts as a facade and gatekeeper between the <em>business layers</em> of the system and the storage facility that in our case happens to be an Oracle database.</p>
<p>In this tutorial, we will briefly take a look at <a href="https://apereo.github.io/cas/development/services/JPA-Service-Management.html">JPA Service Registry</a> support in CAS, with our starting position as follows:</p>
<ul>
<li>CAS <code>6.2.x</code>
</li>
<li><a href="https://github.com/apereo/cas-overlay-template">CAS WAR Overlay</a></li>
<li>Java 11</li>
<li>Docker</li>
</ul>
<h2>
<a id="configuration" class="anchor" href="#configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration</h2>
<p>Let's take a look at our modest task list:</p>
<ul>
<li>(Optional) Start an Oracle database to store application definitions.</li>
<li>Configure CAS to connect to said Oracle database to activate service management.</li>
<li>(Optional) Import application definitions into our Oracle database via CAS.</li>
</ul>
<p>Let's begin.</p>
<h3>
<a id="oracle-setup" class="anchor" href="#oracle-setup" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Oracle Setup</h3>
<p>If you do have an Oracle database at hand, feel free to skip this step. I don't happen to have one readily available so I decided to keep things simple by using a Docker container, off of a fairly sizeable Docker image, to power on an Oracle database instance:</p>
<pre lang="bash"><code>docker run -d -p 1521:1521 --name oracle-db store/oracle/database-enterprise:12.2.0.1-slim
</code></pre>
<p>Be patient. It might some time for Docker to pull down the image and start the container, but once ready, <a href="https://docs.docker.com/engine/reference/commandline/ps/">you should see</a> the following output:</p>
<pre lang="bash"><code>$ docker ps

CONTAINER ID   IMAGE                                             PORTS                              NAMES
a42d53af19f5   store/oracle/database-enterprise:12.2.0.1-slim    0.0.0.0:1521-&gt;1521/tcp, 5500/tcp   oracle-db
</code></pre>
<p>During the process, if you ever needed to start over fresh and spawn a new container, you may kill and remove all traces of the existing running container via the following bash function:</p>
<pre lang="bash"><code>function dkc() {
   export CID=$(docker ps -aqf "name=$1");
   docker stop $CID 2&gt;/dev/null
   docker rm -f $CID 2&gt;/dev/null
   docker volume prune --force
}
</code></pre>
<p>...which allows you to simply pass along the container name as a function parameter to stop and remove the container:</p>
<pre lang="bash"><code>dkc oracle-db
</code></pre>
<!-- raw HTML omitted -->
<p>So back to the task at hand, we will keep this container running in the background and will use it as a testbed to connect it to our CAS instance to store application registration records.</p>
<h3>
<a id="cas-configuration" class="anchor" href="#cas-configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CAS Configuration</h3>
<p>You should start by including the <a href="https://apereo.github.io/cas/development/services/JPA-Service-Management.html">indicated module</a> in your <a href="https://github.com/apereo/cas-overlay-template">CAS WAR Overlay</a>. Of course, we have to introduce CAS and our Oracle database to each other using the following settings:</p>
<pre lang="properties"><code>cas.jdbc.showSql=true

cas.serviceRegistry.jpa.user=system
cas.serviceRegistry.jpa.password=Oradoc_db1
cas.serviceRegistry.jpa.driverClass=oracle.jdbc.driver.OracleDriver
cas.serviceRegistry.jpa.url=jdbc:oracle:thin:@localhost:1521:ORCLCDB
cas.serviceRegistry.jpa.dialect=org.hibernate.dialect.Oracle12cDialect

cas.serviceRegistry.jpa.ddlAuto=update
</code></pre>
<p>That should be all. Once you rebuild and run CAS again, you should see the following in the CAS logs:</p>
<pre lang="bash"><code>INFO [o.a.c.s.AbstractServicesManager] - &lt;Loaded [0] service(s) from [JpaServiceRegistry].&gt;
</code></pre>
<p>In the above settings, we are instructing CAS to achieve the following:</p>
<ul>
<li>Turn on logging for all SQL statements. Doing this allows you to see queries generated by Hibernate for database operations such as <code>SELECT</code> or <code>DELETE</code>, etc.</li>
<li>Connect to our Oracle database using the Docker-provided credentials, connection string, and the appropriate database dialect.</li>
<li>Control Hibernate's DDL processing and generation by attempting to <em>update</em> the database schema if necessary.</li>
</ul>
<p>So at this point, we have a running CAS server talking to our Oracle database. However, as the log message above indicates, we have no services available in our registry so let's populate our database instance by importing a few application definitions.</p>
<!-- raw HTML omitted -->
<h3>
<a id="import-applications" class="anchor" href="#import-applications" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Import Applications</h3>
<p>Based on the CAS documentation, our JPA service registry is able to auto initialize itself from default JSON service definitions available to CAS. The initializer can detect all service definitions files found on the classpath (i.e. <code>src/main/resources/services</code>) and import them into the <em>real</em> service registry used. Note that the location of the JSON files, while typically set to the classpath, may be controlled via CAS properties; The same setting that controls the location of the JSON service files for the JSON service registry is used by the initialization logic to locate service files.</p>
<p>So let's instruct CAS to initialize itself from JSON definitions that can be found in our given path:</p>
<pre lang="properties"><code>cas.serviceRegistry.initFromJson=true
cas.serviceRegistry.json.location=file:/etc/cas/config/services
</code></pre>
<p>Our <code>/etc/cas/config/services</code> directory should contain the following files to be importted:</p>
<pre lang="bash"><code>$ ls /etc/cas/config/services

Permissions Size User   Group Date Modified Name
.rw-r--r--   488 Misagh wheel 30 Sep  2019  Sample-100.json
</code></pre>
<p>Our <code>Sample-100.json</code> file as an example contains the following:</p>
<pre lang="json"><code>{
    "@class": "org.apereo.cas.services.RegexRegisteredService",
    "serviceId": "https://mmoayyed.example.net:9443/sample.*",
    "name": "Sample",
    "id": 100,
    "description": "Sample Java CASified application"
}
</code></pre>
<p>If you build and run CAS again, you should see the following output in your CAS logs:</p>
<pre lang="bash"><code>INFO [o.a.c.c.CasServiceRegistryInitializationConfiguration] - &lt;Attempting to initialize the service registry \
  [EmbeddedResourceBasedServiceRegistry,JpaServiceRegistry] from service definition resources \
  found at [URL [file:/etc/cas/config/services]]&gt;
...
...
&lt;Loaded [2] service(s) from [EmbeddedResourceBasedServiceRegistry,JpaServiceRegistry].&gt;
</code></pre>
<p>While the above output may be somewhat cryptic, what it's saying is that two service registries are active:</p>
<ul>
<li>The <code>EmbeddedResourceBasedServiceRegistry</code> which is mainly responsible for loading our service definitions and preparing them for import.</li>
<li>The <code>JpaServiceRegistry</code> which is the <em>real</em> registry and the target destination for the import operation.</li>
</ul>
<p>From here on out, <code>JpaServiceRegistry</code> will be regarded as the main service registry. To confirm the import, you can always double-check the state of the database:</p>
<p><img src="https://user-images.githubusercontent.com/1205228/78793465-b330e400-79c7-11ea-813d-9be27e74cdf6.png" alt="image"></p>
<p>Of course, remember to turn off or remove the below settings when you're done:</p>
<pre lang="properties"><code># cas.serviceRegistry.initFromJson=true
# cas.serviceRegistry.json.location=file:/etc/cas/config/services
</code></pre>
<h2>
<a id="finale" class="anchor" href="#finale" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Finale</h2>
<p>I hope this review was of some help to you and I am sure that both this post as well as the functionality it attempts to explain can be improved in any number of ways. Please feel free to <a href="https://apereo.github.io/cas/developer/Contributor-Guidelines.html">engage and contribute</a> as best as you can.</p>
<p><a href="https://fawnoos.com">Misagh Moayyed</a></p>