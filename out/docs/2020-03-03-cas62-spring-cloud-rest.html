<hr>
<h2>
<a id="layout-----posttitle------apereo-cas---bootstrapping-configuration-via-restsummary----bootstrapping-the-cas-application-context-using-external-rest-apis-while-taking-advantage-of-spring-clouds-ability-to-dynamically-refresh-and-reload-settingspublished-truetags-------cas" class="anchor" href="#layout-----posttitle------apereo-cas---bootstrapping-configuration-via-restsummary----bootstrapping-the-cas-application-context-using-external-rest-apis-while-taking-advantage-of-spring-clouds-ability-to-dynamically-refresh-and-reload-settingspublished-truetags-------cas" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>layout:     post<br>
title:      Apereo CAS - Bootstrapping Configuration via REST<br>
summary:    Bootstrapping the CAS application context using external REST APIs, while taking advantage of Spring Cloud's ability to dynamically refresh and reload settings.<br>
published: true<br>
tags:       [CAS]</h2>
<p>Since the adoption of Spring Boot and Spring Cloud, Apereo CAS could bootstrap its running application context using a variety of external property and settings sources such as the <a href="https://apereo.github.io/cas/development/configuration/Configuration-Server-Management.html">Spring Cloud Configuration Server</a> as well as MongoDb, JDBC, etc. In this walkthrough, we will take a look at how a given CAS server can bootstrap itself using an <a href="https://apereo.github.io/cas/development/configuration/Configuration-Server-Management.html#rest">external REST API</a> to auto-configure features and behavior while also keeping the ability to dynamically reload the configuration at runtime and on-demand.</p>
<p>Our starting position is based on the following:</p>
<ul>
<li>CAS <code>6.2.x</code>
</li>
<li><a href="https://github.com/apereo/cas-overlay-template">CAS WAR Overlay</a></li>
<li>Java 11</li>
</ul>
<h2>
<a id="configuration" class="anchor" href="#configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration</h2>
<p>To bootstrap the CAS application context using a REST API, the following dependencies must first be included in the Overlay:</p>
<pre lang="groovy"><code>implementation "org.apereo.cas:cas-server-support-configuration-cloud-rest:${casServerVersion}"
implementation "org.apereo.cas:cas-server-core-events-configuration:${casServerVersion}"
</code></pre>
<p>The above modules allow the CAS server to bootstrap and initialize itself with settings fetched from a REST endpoint while also allowing the system to intercept configuration events and reload/refresh itself dynamically when requested via Spring Cloud Actuator endpoints.</p>
<p>Of course, the location of our yet-to-be-designed REST API can be passed along as a system property when running the Overlay:</p>
<pre lang="bash"><code>./gradlew build run -Dcas.spring.cloud.rest.url=https://rest.example.io/casproperties
</code></pre>
<p>The default expectation is for CAS to reach out to the endpoint via <code>GET</code> and receive a collection of settings paired as <code>key=value</code>. At this point, we are ready to design our REST endpoint.</p>
<h2>
<a id="rest-api" class="anchor" href="#rest-api" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>REST API</h2>
<p>Our <code>/casproperties</code> endpoint quite simply is going to produce a collection of settings which are valid and recognizable by CAS or any other library/framework used by the system such as Spring Cloud, Spring Security, etc. At a minimum, let's have our endpoint return the following settings:</p>
<pre lang="json"><code>{
    "cas.monitor.endpoints.endpoint.defaults.access": "AUTHENTICATED",

    "management.endpoints.web.exposure.include": "*", 
    "management.endpoints.enabled-by-default": "true",

    "spring.security.user.name": "casuser",
    "spring.security.user.password": "Mellon",
    
    "server.port": 8080,
    "server.ssl.enabled": false,
    
    "logging.level.org.apereo.cas": "trace"
}
</code></pre>
<p>Using the above settings, our REST API is going to dictate the following behavior to CAS:</p>
<ol>
<li>Expose and enable all actuator endpoints.</li>
<li>Require basic authentication with credentials <code>casuser/Mellon</code> for secure access to all endpoints.</li>
<li>Run the server on port <code>8080</code> with SSL disabled.</li>
<li>Turn up logging for <code>org.apereo.cas</code> to <code>trace</code>.</li>
</ol>
<!-- raw HTML omitted -->
<p>As you observe, the produced settings are a combined mix of those controlled by CAS and some provided by Spring Boot. When you run CAS, at a minimum you should see the following in the application logs:</p>
<pre lang="bash"><code>...
INFO [o.s.b.w.e.t.TomcatWebServer] - &lt;Tomcat initialized with port(s): 8080 (http)&gt;
...
</code></pre>
<p>...where the running server would be available at <code>http://localhost:8080/cas/login</code>.</p>
<h2>
<a id="refresh--reload" class="anchor" href="#refresh--reload" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Refresh &amp; Reload</h2>
<p>The CAS server can dynamically alter itself once it receives <em>a refresh request</em>. Using this strategy, one can modify values and settings in the configuration store (backed by our REST API) and then send a notification request to the CAS server to update its state. The configuration management, retrieval and <em>refreshability</em> of components are all managed by Spring Cloud and family.</p>
<p>As an example, let's modify our REST API to produce the following:</p>
<pre lang="json"><code>{
    "cas.monitor.endpoints.endpoint.defaults.access": "AUTHENTICATED",

    "management.endpoints.web.exposure.include": "*", 
    "management.endpoints.enabled-by-default": "true",

    "spring.security.user.name": "casuser",
    "spring.security.user.password": "Mellon",
    
    "server.port": 8080,
    "server.ssl.enabled": false,
    
    "logging.level.org.apereo.cas": "info",
    "logging.level.org.springframework.boot": "debug"
}
</code></pre>
<p>The new settings are more or less the same with the following notable differences:</p>
<ul>
<li>We enabled <code>debug</code> logging for <code>org.springframework.boot</code>.</li>
<li>We updated the logging level to <code>info</code> for <code>org.apereo.cas</code>.</li>
</ul>
<p>Once changes are saved, the CAS server can begin to refresh its state to collect and rejuvenate the application context via:</p>
<pre lang="bash"><code>curl -k -u casuser:Mellon http://localhost:8080/cas/actuator/refresh -d {} -H "Content-Type: application/json"
</code></pre>
<p>The response should outline the collection of settings that were affected and refreshed.</p>
<h2>
<a id="how" class="anchor" href="#how" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>How?</h2>
<p>Throughout the CAS codebase, components designed as Spring <code>@Bean</code>s that are marked as <code>@RefreshScope</code> will get special treatment when there is a configuration change. Refresh scope beans are lazy proxies that initialize when they are used and the scope acts as a cache of initialized values. Tagging a bean as <em>Refreshable</em> allows the Spring infrastructure to invalidate and clear its cached version where the invalidation operation can either be done globally or for a specific bean by its name. This functionality is exposed to the <code>/refresh</code> endpoint (over HTTP or JMX).</p>
<p>To learn more, please review <a href="https://cloud.spring.io/spring-cloud-static/spring-cloud.html#_refresh_scope">the Spring Cloud documentation</a>.</p>
<h2>
<a id="what-else" class="anchor" href="#what-else" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>What Else?</h2>
<ul>
<li>
<p>Spring Cloud also presents the ability to distribute the refresh request, if the receiving application (CAS) is distributed in a clustered deployment. This is managed using the Spring Cloud Bus.</p>
</li>
<li>
<p>Components that can be refreshed are marked with <code>@RefreshScope</code> judiciously. Not every component has to be refreshable and certain beans should not be reloadable anyway. A bean's ability to reload its state must be a privilege and not a right.</p>
</li>
</ul>
<h2>
<a id="finale" class="anchor" href="#finale" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Finale</h2>
<p>I hope this review was of some help to you and I am sure that both this post as well as the functionality it attempts to explain can be improved in any number of ways. Please feel free to <a href="https://apereo.github.io/cas/developer/Contributor-Guidelines.html">engage and contribute</a> as best as you can.</p>
<p><a href="https://fawnoos.com">Misagh Moayyed</a></p>