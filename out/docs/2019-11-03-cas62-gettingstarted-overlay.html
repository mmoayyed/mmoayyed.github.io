<hr>
<h2>
<a id="layout-----posttitle------cas-62x-deployment---war-overlayssummary----learn-how-to-configure-and-build-your-own-cas-deployment-via-the-war-overlay-method-get-rich-quickly-stay-healthy-indefinitely-and-respect-family-and-friends-in-a-few-very-easy-stepstags-------cas" class="anchor" href="#layout-----posttitle------cas-62x-deployment---war-overlayssummary----learn-how-to-configure-and-build-your-own-cas-deployment-via-the-war-overlay-method-get-rich-quickly-stay-healthy-indefinitely-and-respect-family-and-friends-in-a-few-very-easy-stepstags-------cas" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>layout:     post<br>
title:      CAS 6.2.x Deployment - WAR Overlays<br>
summary:    Learn how to configure and build your own CAS deployment via the WAR overlay method, get rich quickly, stay healthy indefinitely and respect family and friends in a few very easy steps.<br>
tags:       [CAS]</h2>
<p>This is a short and sweet tutorial on how to deploy CAS via <a href="https://apereo.github.io/cas/6.2.x/installation/WAR-Overlay-Installation.html">the WAR Overlay method</a>.</p>
<p>This tutorial specifically requires and focuses on:</p>
<ul>
<li>CAS <code>6.2.x</code>
</li>
<li>Java 11</li>
</ul>
<!-- raw HTML omitted -->
<ul>
<li>A markdown unordered list which will be replaced with the ToC<br>
{:toc}</li>
</ul>
<h1>
<a id="overlaywhat" class="anchor" href="#overlaywhat" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overlay...What?</h1>
<p>Overlays are a strategy to combat repetitive code and/or resources. Rather than downloading the CAS codebase and building it from source, overlays allow you to download a pre-built vanilla CAS web application server provided by the project itself, override/insert specific behavior into it and then merge it all back together to produce the final (web application) artifact. You can find a lot more about how overlays work <a href="https://apereo.github.io/cas/6.2.x/installation/WAR-Overlay-Installation.html">here</a>.</p>
<p>The concept of the WAR Overlay is NOT a CAS invention. It's specifically an <em>Apache Maven</em> feature and of course, there are techniques and plugins available to apply the same concept to Gradle-based builds as well. For this tutorial, the Gradle overlay we will be working with is <a href="https://github.com/apereo/cas-overlay-template">available here</a>. Be sure to check out the appropriate branch, that is <code>6.2</code>.</p>
<!-- raw HTML omitted -->
<p>Once you have forked and cloned the repository locally, you're ready to begin.</p>
<!-- raw HTML omitted -->
<h1>
<a id="overlays-anatomy" class="anchor" href="#overlays-anatomy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overlay's Anatomy</h1>
<p>Similar to Grey's, a <em>Gradle</em> WAR overlay is composed of several facets the most important of which are the <code>build.gradle</code> and <code>gradle.properties</code> file. These are build-descriptor files whose job is to teach Gradle how to obtain, build, configure (and in certain cases deploy) CAS artifacts.</p>
<!-- raw HTML omitted -->
<p>The CAS Gradle Overlay is composed of several sections. The ones you need to worry about are the following.</p>
<h2>
<a id="properties" class="anchor" href="#properties" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Properties</h2>
<p>In <code>gradle.properties</code> file, project settings and versions are specified:</p>
<pre lang="properties"><code>cas.version=6.2.0
springBootVersion=2.2.0.RELEASE

appServer=-tomcat

gradleVersion=5.6.3
tomcatVersion=9
tomcatFullVersion=9.0.27

group=org.apereo.cas
sourceCompatibility=11
targetCompatibility=11
</code></pre>
<p>The <code>gradle.properties</code> file describes what versions of CAS, Spring Boot, and Java are required for the deployment. You are in practice mostly concerned with the <code>cas.version</code> setting and as new (maintenance) releases come out, it would be sufficient to simply update that version and re-run the build.</p>
<p>This might be a good time to review the CAS project's <a href="https://apereo.github.io/cas/developer/Release-Policy.html">Release Policy</a> as well as <a href="https://apereo.github.io/cas/developer/Maintenance-Policy.html">Maintenance Policy</a>.</p>
<h2>
<a id="dependencies" class="anchor" href="#dependencies" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Dependencies</h2>
<p>The next piece describes the <em>dependencies</em> of the overlay build. These are the set of components almost always provided by the CAS project that will be packaged up and put into the final web application artifact. At a minimum, you need to have the <code>cas-server-webapp-${appServer}</code> module available because that is the web application into which you intend to inject your settings and customizations if any. Also, note that the module declarations are typically configured to download the CAS version instructed by the property <code>cas.version</code>.</p>
<p>Here is an example:</p>
<pre lang="groovy"><code>dependencies {
    if (project.hasProperty("external")) {
        compile "org.apereo.cas:cas-server-webapp:${casServerVersion}"
    } else {
        compile "org.apereo.cas:cas-server-webapp${project.appServer}:${casServerVersion}"
    }
    // Other dependencies may be listed here...
}
</code></pre>
<p>Including a CAS module/dependency in the <code>build.gradle</code> simply advertises to CAS <em>your intention</em> of turning on a new feature or a variation of a current behavior. Do NOT include something in your build just because it looks and sounds cool. Remember that the point of an overlay is to only keep track of things you actually need and care about, and no more.</p>
<!-- raw HTML omitted -->
<h1>
<a id="the-build" class="anchor" href="#the-build" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>The Build</h1>
<p>Now that you have a basic understanding of the build descriptor, it's time to actually run the build. A Gradle build is often executed by passing specific goals/commands to Gradle itself, aka <code>gradlew</code>. So for instance in the terminal and once inside the project directory you could execute things like:</p>
<pre lang="bash"><code>cd cas-overlay-template
./gradlew clean
</code></pre>
<p>The WAR Overlay project provides you with an embedded Gradle <em>wrapper</em> whose job is to first determine whether you have Gradle installed. If not, it will download and configure one for you based on the project's needs. The <code>gradlew tasks</code> command describes the set of available operations you may carry out with the build script.</p>
<!-- raw HTML omitted -->
<p>As an example, here's what I see if I were to run the build command:</p>
<pre lang="bash"><code>./gradlew clean copyCasConfiguration build

...
Starting a Gradle Daemon (subsequent builds will be faster)
Configuration on demand is an incubating feature.

BUILD SUCCESSFUL in 14s
2 actionable tasks: 2 executed
...
</code></pre>
<p>You can see that the build attempts to download, clean, compile and package all artifacts, and finally, it produces a <code>build/libs/cas.war</code> which you can then use for actual deployments.</p>
<h1>
<a id="configuration" class="anchor" href="#configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration</h1>
<p>I am going to skip over the configuration of <code>/etc/cas/config</code> and all that it deals with. If you need the reference, you may always <a href="https://apereo.github.io/cas/6.2.x/configuration/Configuration-Management.html">use this guide</a> to study various aspects of CAS configuration.</p>
<p>Suffice it to say that, quite simply, CAS deployment expects <em>the main</em> configuration file to be found under <code>/etc/cas/config/cas.properties</code>. This is a key-value store that is able to dictate and alter the behavior of the running CAS software.</p>
<p>As an example, you might encounter something like:</p>
<pre lang="properties"><code>cas.server.name=https://cas.example.org:8443
cas.server.prefix=${cas.server.name}/cas
logging.config=file:/etc/cas/config/log4j2.xml
</code></pre>
<p>...which at a minimum, identifies the CAS server's URL and prefix and instructs the running server to locate the logging configuration at <code>file:/etc/cas/config/log4j2.xml</code>. The overlay by default ships with a <code>log4j2.xml</code> that you can use to customize logging locations, levels, etc. Note that the presence of all that is contained inside <code>/etc/cas/config/</code> is optional. CAS will continue to fall back onto defaults if the directory and the files within are not found.</p>
<h2>
<a id="keep-track" class="anchor" href="#keep-track" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Keep Track</h2>
<p>It is <strong>VERY IMPORTANT</strong> that you contain and commit the entire overlay directory (save the obvious exclusions such as the <code>build</code> directory) into some sort of source control system, such as <code>git</code>. Treat your deployment just like any other project with tags, releases, and functional baselines.</p>
<h1>
<a id="ldap-authentication" class="anchor" href="#ldap-authentication" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>LDAP Authentication</h1>
<p>We need to first establish a primary mode of validating credentials by sticking with <a href="https://apereo.github.io/cas/6.2.x/installation/LDAP-Authentication.html">LDAP authentication</a>. The strategy here, as indicated by the CAS documentation, is to declare the intention/module in the build script:</p>
<pre lang="groovy"><code>compile "org.apereo.cas:cas-server-support-ldap:${casServerVersion}"
</code></pre>
<p>...and then configure the relevant <code>cas.authn.ldap[x]</code> settings for the directory server in use. Most commonly, that would translate into the following settings:</p>
<pre lang="properties"><code>cas.authn.ldap[0].type=AUTHENTICATED
cas.authn.ldap[0].ldapUrl=ldaps://ldap1.example.org
cas.authn.ldap[0].baseDn=dc=example,dc=org
cas.authn.ldap[0].searchFilter=cn={user}
cas.authn.ldap[0].bindDn=cn=Directory Manager,dc=example,dc=org
cas.authn.ldap[0].bindCredential=...
</code></pre>
<p>To resolve and fetch the needed attributes which will be used later by CAS for release, the simplest way would be to let LDAP authentication retrieve the attributes directly from the directory server.  The following setting allows us to do just that:</p>
<pre lang="properties"><code>cas.authn.ldap[0].principalAttributeList=memberOf,cn,givenName,mail
</code></pre>
<h1>
<a id="registering-applications" class="anchor" href="#registering-applications" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Registering Applications</h1>
<p>Client applications that wish to use the CAS server for authentication must be registered with the server apriori. CAS provides a number of <a href="https://apereo.github.io/cas/6.2.x/services/Service-Management.html#storage">facilities to keep track of the registration records</a> and you may choose any that fits your needs best. In more technical terms, CAS deals with service management using two specific components: Individual implementations that support a form of a database are referred to as <em>Service Registry</em> components and they are many. There is also a parent component that sits on top of the configured service registry as more of an orchestrator that provides a generic facade and entry point for the rest of CAS without entangling all other operations and subsystems with the specifics and particulars of a storage technology.</p>
<p>In this tutorial, we are going to try to configure CAS with <a href="https://apereo.github.io/cas/6.2.x/services/JSON-Service-Management.html">the JSON service registry</a>.</p>
<h2>
<a id="configuration-1" class="anchor" href="#configuration-1" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration</h2>
<p>First, ensure you have declared the appropriate module/intention in the build:</p>
<pre lang="groovy"><code>compile "org.apereo.cas:cas-server-support-json-service-registry:${casServerVersion}"
</code></pre>
<p>Next, you must teach CAS how to look up JSON files to read and write registration records. This is done in the <code>cas.properties</code> file:</p>
<pre lang="properties"><code>cas.serviceRegistry.initFromJson=false
cas.serviceRegistry.json.location=file:/etc/cas/services
</code></pre>
<p>...where a sample <code>ApplicationName-1001.json</code> would then be placed inside <code>/etc/cas/services</code>:</p>
<pre lang="json"><code>{
  "@class" : "org.apereo.cas.services.RegexRegisteredService",
  "serviceId" : "https://app.example.org",
  "name" : "ApplicationName",
  "id" : 1001,
  "evaluationOrder" : 10
}
</code></pre>
<h1>
<a id="ticketing" class="anchor" href="#ticketing" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Ticketing</h1>
<p>A robust CAS deployment requires the presence and configuration of an <em>internal</em> database that is responsible for <a href="https://apereo.github.io/cas/6.2.x/ticketing/Configuring-Ticketing-Components.html">keeping track of tickets</a> issued by CAS. CAS itself comes by default with a memory-based node-specific cache that is often more than sufficient for smaller deployments or certain variations of a <a href="https://apereo.github.io/cas/6.2.x/planning/High-Availability-Guide.html">clustered deployment</a>. Just like the service management facility, large variety of databases and storage options are supposed by CAS under the facade of a <em>Ticket Registry</em>.</p>
<p>In this tutorial, we are going to configure CAS to use a <a href="https://apereo.github.io/cas/6.2.x/ticketing/Hazelcast-Ticket-Registry.html">Hazelcast Ticket Registry</a> with the assumption that our deployment is going to be deployed in an AWS-sponsored environment. Hazelcast Ticket Registry is often a decent choice when deploying CAS in a cluster and can take advantage of AWS's native support for Hazelcast in order to read node metadata properly and locate other CAS nodes in the same cluster in order to present a common, global and shared ticket registry. This is an ideal choice that requires very little manual work and/or troubleshooting, comparing to using options such as Multicast or manually noting down the address and location of each CAS server in the cluster.</p>
<h2>
<a id="configuration-2" class="anchor" href="#configuration-2" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration</h2>
<p>First, ensure you have declared the appropriate module/intention in the build:</p>
<pre lang="groovy"><code>compile "org.apereo.cas:cas-server-support-hazelcast-ticket-registry:${casServerVersion}"
</code></pre>
<p>Next, the AWS-specific configuration of Hazelcast would go into our <code>cas.properties</code>:</p>
<pre lang="properties"><code>cas.ticket.registry.hazelcast.cluster.discovery.enabled=true
cas.ticket.registry.hazelcast.cluster.discovery.aws.accessKey=...
cas.ticket.registry.hazelcast.cluster.discovery.aws.secretKey=...
cas.ticket.registry.hazelcast.cluster.discovery.aws.region=us-east-1
cas.ticket.registry.hazelcast.cluster.discovery.aws.securityGroupName=...
# cas.ticket.registry.hazelcast.cluster.discovery.aws.tagKey=
# cas.ticket.registry.hazelcast.cluster.discovery.aws.tagValue=
</code></pre>
<p>That should do it.</p>
<p>Of course, if you are working on a more modest CAS deployment in an environment that is more or less owned by you and you prefer more explicit control over CAS node registrations in your cluster, the following settings would be more ideal:</p>
<pre lang="properties"><code># cas.ticket.registry.hazelcast.cluster.instanceName=localhost
# cas.ticket.registry.hazelcast.cluster.port=5701
# cas.ticket.registry.hazelcast.cluster.portAutoIncrement=true
cas.ticket.registry.hazelcast.cluster.members=123.321.123.321,223.621.123.521,...
</code></pre>
<h1>
<a id="multifactor-authentication-via-duo-security" class="anchor" href="#multifactor-authentication-via-duo-security" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Multifactor Authentication via Duo Security</h1>
<p>As a rather common use case, the majority of CAS deployments that intend to turn on multifactor authentication support tend to do so via <a href="https://apereo.github.io/cas/6.2.x/installation/DuoSecurity-Authentication.html">Duo Security</a>. We will be going through the same exercise here where we let CAS trigger Duo Security for users who belong to the <code>mfa-eligible</code> group, indicated by the <code>memberOf</code> attribute on the LDAP user account.</p>
<h2>
<a id="configuration-3" class="anchor" href="#configuration-3" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration</h2>
<p>First, ensure you have declared the appropriate module/intention in the build:</p>
<pre lang="groovy"><code>compile "org.apereo.cas:cas-server-support-duo:${casServerVersion}"
</code></pre>
<p>Then, put specific Duo Security settings in `cas.properties. Things such as the secret key, integration key, etc which should be provided by your Duo Security subscription:</p>
<pre lang="properties"><code>cas.authn.mfa.duo[0].duoSecretKey=
cas.authn.mfa.duo[0].duoApplicationKey=
cas.authn.mfa.duo[0].duoIntegrationKey=
cas.authn.mfa.duo[0].duoApiHost=
</code></pre>
<p>At this point, we have enabled Duo Security and we just need to find a way to instruct CAS to route the authentication flow over to Duo Security in the appropriate condition. Our task here is to build a special condition that activates multifactor authentication if any of the values assigned to the attribute <code>memberOf</code> contain the value <code>mfa-eligible</code>. This condition is placed in the <code>cas.properties</code> file:</p>
<pre lang="properties"><code>cas.authn.mfa.globalPrincipalAttributeNameTriggers=memberOf
cas.authn.mfa.globalPrincipalAttributeValueRegex=mfa-eligible
</code></pre>
<p>If the above condition holds true and CAS is to route to a multifactor authentication flow, that would obviously be one supported and provided by Duo Security since that’s the only provider that is currently configured to CAS.</p>
<h1>
<a id="monitoring--status" class="anchor" href="#monitoring--status" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Monitoring &amp; Status</h1>
<p>Many CAS deployments rely on the <code>/status</code> endpoint for monitoring the health and activity of the CAS deployment. This endpoint is typically secured via an IP address, allowing external monitoring tools and load balancers to reach the endpoint and parse the output. In this quick exercise, we are going to accomplish that task, allowing the <code>status</code> endpoint to be available over HTTP to <code>localhost</code>.</p>
<h2>
<a id="configuration-4" class="anchor" href="#configuration-4" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration</h2>
<p>First, ensure you have declared the appropriate module/intention in the build:</p>
<pre lang="groovy"><code>compile "org.apereo.cas:cas-server-support-monitor:${casServerVersion}"
</code></pre>
<p>To enable and expose the <code>status</code> endpoint, the following settings should come in handy:</p>
<pre lang="properties"><code>management.endpoints.web.base-path=/actuator
management.endpoints.web.exposure.include=status
management.endpoint.status.enabled=true

cas.monitor.endpoints.endpoint.status.access=IP_ADDRESS
cas.monitor.endpoints.endpoint.status.requiredIpAddresses=127.0.0.1
</code></pre>
<p>Remember that the default path for endpoints exposed over the web is at <code>/actuator</code>, such as <code>/actuator/status</code>.</p>
<h1>
<a id="overlay-customization" class="anchor" href="#overlay-customization" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overlay Customization</h1>
<p>The <code>build/libs</code> directory contains the results of the overlay process. Since I have not actually customized and overlaid anything yet, all configuration files simply match their default and are packaged as such. As an example, let's grab <a href="https://apereo.github.io/cas/6.2.x/ux/User-Interface-Customization-Localization.html">the default message bundle</a> and change the text associated with <code>screen.welcome.instructions</code>.</p>
<!-- raw HTML omitted -->
<p>First, I will need to move the file to my project directory so that during the overlay process Gradle can use that instead of what is provided by default.</p>
<p>Here we go:</p>
<pre lang="bash"><code>./gradlew getResource -PresourceName=messages.properties
</code></pre>
<p>Then I'll leave everything in that file alone, except the line I want to change.</p>
<pre lang="properties"><code>...
screen.welcome.instructions=Speak friend and enter.
...
</code></pre>
<p>Then I'll package things up as usual.</p>
<pre lang="bash"><code>./gradlew clean build
</code></pre>
<p>If I <code>explode</code> the built web application again and look at <code>build/cas/WEB-INF/classes/messages.properties</code> after the build, I should see that the overlay process has picked and overlaid onto the default <em>my version</em> of the file.</p>
<!-- raw HTML omitted -->
<h1>
<a id="user-interface-customizations" class="anchor" href="#user-interface-customizations" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>User Interface Customizations</h1>
<p>In order to modify the CAS HTML views, each file first needs to be brought over into the overlay. You can use the <code>./gradlew listTemplateViews</code> command to see what HTML views are available for customizations. Once chosen, simply use <code>./gradlew getResource -PresourceName=footer.html</code> to bring the view into your overlay. Once you have the <code>footer.html</code> brought into the overlay, you can simply modify the file at <code>src/main/resources/templates/fragments/footer.html</code>, and then repackage and run the build as usual.</p>
<h1>
<a id="deploy" class="anchor" href="#deploy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Deploy</h1>
<p>You have a number of options when it comes to deploying the final <code>cas.war</code> file. The easiest approach would be to simply use the <code>./gradlew run</code> command and have the overlay be deployed inside an embedded container. By default, the CAS web application expects to run on the secure port <code>8443</code> which requires that you create a keystore file at <code>/etc/cas/</code> named <code>thekeystore</code>.</p>
<h2>
<a id="deploy-behind-a-proxy" class="anchor" href="#deploy-behind-a-proxy" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Deploy Behind a Proxy</h2>
<p>Using the embedded Apache Tomcat container provided by CAS automatically is the recommended approach in almost all cases (The embedded bit; not the Apache Tomcat bit) as the container configuration is entirely automated by CAS and its version is guaranteed to be compatible with the running CAS deployment. Furthermore, updates and maintenance of the servlet container are handled at the CAS project level where you as the adopter are only tasked with making sure your deployment is running the latest available release to take advantage of such updates.</p>
<p>If you wish to run CAS via the embedded Apache Tomcat container behind a proxy or load balancer and have that entity terminate SSL, you will need to open up a communication channel between the proxy and CAS such that (as an example):</p>
<ul>
<li>Apache Tomcat runs on port 8080, assuming that’s what the proxy uses to talk to CAS.</li>
<li>Apache Tomcat has SSL turned off.</li>
<li>Apache Tomcat connector listening on the above port is marked as secure.</li>
</ul>
<p>The above tasklist translates to the following properties expected to be found in your <code>cas.properties</code>:</p>
<pre lang="properties"><code>server.port=8080
server.ssl.enabled=false
cas.server.tomcat.http.enabled=false
cas.server.tomcat.httpProxy.enabled=true
cas.server.tomcat.httpProxy.secure=true
cas.server.tomcat.httpProxy.scheme=https
</code></pre>
<h2>
<a id="deploy-via-docker" class="anchor" href="#deploy-via-docker" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Deploy via Docker</h2>
<p>The overlay embraces the Jib Gradle Plugin to provide easy-to-use out-of-the-box tooling for building CAS docker images. Jib is an open-source Java containerizer from Google that handles all the steps of packaging CAS into a container image. It does not require you to write a Dockerfile and it is directly integrated into the overlay.</p>
<p>Building a CAS docker image via jib is as simple as:</p>
<pre lang="bash"><code>./gradlew build jibDockerBuild
</code></pre>
<p>If you prefer a more traditional approach, there is always:</p>
<pre lang="bash"><code>./gradlew build
docker-compose build
</code></pre>
<h1>
<a id="so" class="anchor" href="#so" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>So...</h1>
<p>It's important that you start off simple and make changes one step at a time. Once you have a functional environment, you can gradually and slowly add customizations to move files around.</p>
<p>I hope this review was of some help to you and I am sure that both this post as well as the functionality it attempts to explain can be improved in any number of ways. Please feel free to <a href="https://apereo.github.io/cas/developer/Contributor-Guidelines.html">engage and contribute</a> as best as you can.</p>
<p><a href="https://fawnoos.com">Misagh Moayyed</a></p>