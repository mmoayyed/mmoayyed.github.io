<hr>
<h2>
<a id="layout-----posttitle------apereo-cas---integration-with-spring-cloud-config-serversummary----cas-distributed-configuration-management-using-spring-cloud-server-for-fun-and-profit-learn-how-to-centralize-and-setup-configuration-and-property-sources-as-part-of-the-cloud-config-server-and-how-to-connect-your-apereo-cas-deployment-to-the-cloud-config-server-to-receive-real-time-configuration-updates-per-environment-and-deployment-tiertags-------cas" class="anchor" href="#layout-----posttitle------apereo-cas---integration-with-spring-cloud-config-serversummary----cas-distributed-configuration-management-using-spring-cloud-server-for-fun-and-profit-learn-how-to-centralize-and-setup-configuration-and-property-sources-as-part-of-the-cloud-config-server-and-how-to-connect-your-apereo-cas-deployment-to-the-cloud-config-server-to-receive-real-time-configuration-updates-per-environment-and-deployment-tiertags-------cas" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>layout:     post<br>
title:      Apereo CAS - Integration with Spring Cloud Config Server<br>
summary:    CAS distributed configuration management using Spring Cloud Server for fun and profit. Learn how to centralize and setup configuration and property sources as part of the Cloud Config server and how to connect your Apereo CAS deployment to the Cloud Config server to receive real-time configuration updates per environment and deployment tier.<br>
tags:       [CAS]</h2>
<!-- raw HTML omitted -->
<p>As your CAS deployment moves through the deployment pipeline from dev to test to production, you can manage the configuration between those environments and be certain that applications have everything they need to run when they migrate through the use of an external configuration server provided by the <a href="https://github.com/spring-cloud/spring-cloud-config">Spring Cloud project</a>. While most CAS deployments tend to fall into the simpler category of managing CAS configuration directly alongside the CAS server deployment, this tutorial focuses on allowing CAS to work with the Spring Cloud Config server for distributed configuration management.</p>
<p>The <a href="https://apereo.github.io/cas/development/configuration/Configuration-Server-Management.html">Spring Cloud Config server</a> is an external and central configuration server to keep state and settings for all sorts of applications, CAS included. It provides an abstract way for CAS (and all of its other clients) to obtain settings from a variety of sources such as file system, git or svn repositories, MongoDb databases, Vault, etc. The beauty of this solution is that to the CAS web application server, (or the clients of the Spring Cloud Config server in general), it matters not where settings come from since CAS has no knowledge of the underlying property sources. It simply talks to the configuration server to locate settings and move on.</p>
<p>In this walkthrough, we will focus on the following tasks:</p>
<ul>
<li>Spring Cloud Config Server deployment
<ul>
<li>Property source configuration</li>
<li>Endpoint and operational security</li>
<li>Managing sensitive settings via encryption</li>
<li>Distributed real-time updates to settings</li>
</ul>
</li>
<li>CAS server integration with the Config server</li>
</ul>
<p>Our starting position is based on the following:</p>
<ul>
<li>CAS <code>6.0.0-RC3</code>
</li>
<li>Java 11</li>
<li>
<a href="https://github.com/apereo/cas-overlay-template">CAS Overlay</a> (The <code>master</code> branch specifically)</li>
<li><a href="https://github.com/apereo/cas-configserver-overlay">CAS Spring Cloud Config server overlay</a></li>
<li><a href="https://stedolan.github.io/jq/">CLI JSON Processor <code>jq</code></a></li>
</ul>
<h2>
<a id="spring-cloud-config-server-configuration" class="anchor" href="#spring-cloud-config-server-configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Spring Cloud Config Server Configuration</h2>
<h3>
<a id="overlay-basics" class="anchor" href="#overlay-basics" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Overlay Basics</h3>
<p>The Spring Cloud Config server runs a standalone Spring Boot application on its own with a setup that is very similar to the CAS server itself. There is a <a href="https://github.com/apereo/cas-configserver-overlay">WAR overlay</a> that can be used to configure and deploy the server. By default, the application runs on port <code>8888</code> and is available at <code>/casconfigserver</code> and does require SSL with a keystore that is expected at <code>file:/etc/cas/thekeystore</code>. The default settings should match the following:</p>
<pre lang="properties"><code>server.port=8444

server.ssl.key-store=file:/etc/cas/thekeystore
server.ssl.key-store-password=changeit
server.ssl.key-password=changeit
</code></pre>
<h3>
<a id="security" class="anchor" href="#security" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Security</h3>
<p>In order to secure the Config server, we can create a <code>src/main/resources/application-security.properties</code> to contain the following settings:</p>
<pre lang="properties"><code>spring.security.user.name=casuser
spring.security.user.password=Mellon

management.endpoints.web.base-path=/actuator
management.endpoints.env.enabled=true
management.endpoints.web.exposure.include=env
</code></pre>
<h3>
<a id="run" class="anchor" href="#run" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Run</h3>
<p>We should also modify the <code>build.sh</code> file to auto-activate the <code>security</code> profile to allow our security-related settings to be loaded:</p>
<pre lang="bash"><code>function run() {
    package &amp;&amp; java -jar -Dspring.profiles.include=security build/libs/casconfigserver.war
}
</code></pre>
<p>Once you're ready, execute the following:</p>
<pre lang="bash"><code>./build.sh run
</code></pre>
<p>...at which point a successful startup attempt would demonstrate the following in the logs:</p>
<pre><code>&lt;The following profiles are active: security,native&gt;
...
&lt;Starting Servlet Engine: Apache Tomcat/9.0.12&gt;
...
&lt;Starting ProtocolHandler ["https-jsse-nio-8888"]&gt;
...
&lt;Started CasConfigurationServerWebApplication in 14.823 seconds (JVM running for 16.248)&gt;
</code></pre>
<p>...and the server should be available at <code>https://admin.example.org:8888/casconfigserver</code>.</p>
<h3>
<a id="configuration-sources" class="anchor" href="#configuration-sources" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration Sources</h3>
<p>The Spring Cloud Config server by default runs under a <code>native</code> profile, which basically allows it to locate properties and settings under the <code>/etc/cas/config</code> folder, which is very similar to the default CAS server setup. We are going to take this one step further and allow it to also load settings from a git repository. To do this, we need a <code>src/main/resources/bootstrap.properties</code> file with the following:</p>
<pre lang="properties"><code>spring.application.name=casconfigserver
spring.profiles.active=native,default,security
spring.cloud.config.server.native.searchLocations=file:///etc/cas/config
spring.cloud.config.server.git.uri=file://path/to/config-server-repo
# spring.cloud.config.server.bootstrap=true
</code></pre>
<p>Not only the Config server is loading properties from embedded resources on the classpath, but it is also configured to look at <code>/etc/cas/config</code> as well as our Git repository at <code>config-server-repo</code> which is expected to contain properties and settings. As an example, we can create and initialize the <code>config-server-repo</code> directory as a Git repository and then <strong>add and commit</strong> the following files to it:</p>
<h4>
<a id="applicationyml" class="anchor" href="#applicationyml" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><code>application.yml</code>
</h4>
<p>Global settings regardless of the application:</p>
<pre lang="yml"><code>info:
  description: Spring Cloud Config Server
</code></pre>
<h4>
<a id="casproperties" class="anchor" href="#casproperties" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><code>cas.properties</code>
</h4>
<p>Global settings for the <code>cas</code> application:</p>
<pre lang="properties"><code>server.port=8555
</code></pre>
<h4>
<a id="cas-devproperties" class="anchor" href="#cas-devproperties" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><code>cas-dev.properties</code>
</h4>
<p>Settings for the <code>cas</code> application under the <code>dev</code> profile:</p>
<pre lang="properties"><code>cas.authn.accept.users=casuser::Devel
</code></pre>
<h4>
<a id="cas-qaproperties" class="anchor" href="#cas-qaproperties" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a><code>cas-qa.properties</code>:</h4>
<p>Settings for the <code>cas</code> application under the <code>qa</code> profile:</p>
<pre lang="properties"><code>cas.authn.accept.users=casuser::QA
</code></pre>
<p>Build and run as usual.</p>
<h3>
<a id="query-configuration" class="anchor" href="#query-configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Query Configuration</h3>
<p>Now that the Config server is connected to a number of property sources with a number of files organized in fancy ways, we can query the server and ask for application settings.</p>
<p>For example, ask the server to get all the configuration settings for <code>cas</code> under the <code>qa</code> profile:</p>
<pre lang="bash"><code>curl -k -u casuser:Mellon https://config.example.org:8888/casconfigserver/cas/qa | jq
</code></pre>
<p>...or the <code>dev</code> profile:</p>
<pre lang="bash"><code>curl -k -u casuser:Mellon https://config.example.org:8888/casconfigserver/cas/dev | jq
</code></pre>
<p>Notice how in each scenario, global settings, and common application settings and then profile-specific settings are returned back to you. As the caller, you don't know where the settings come from or how they are controlled and by whom. All you need to know is: <em>Get me the right set of settings for my app at this profile</em>.</p>
<p>Let's make a change. Navigate to the <code>cas-qa.properties</code> file and add the following, then commit the change to the repository:</p>
<pre lang="properties"><code>cas.authn.accept.users=casuser::QASomething
</code></pre>
<p>...and the call the Config server again:</p>
<pre lang="bash"><code>curl -k -u casuser:Mellon https://config.example.org:8888/casconfigserver/cas/qa | jq
</code></pre>
<p>Notice how your change was picked up automatically. As a bonus exercise, push your git repository to a cloud provider such as Github or Bitbucket and modify the Config server with the URL of the new Git repository. Then make a change using the Github/BitBucket online editor to one of the settings and observe how the Config server recognizes changes automatically. Very cool!</p>
<h3>
<a id="sensitive-configuration" class="anchor" href="#sensitive-configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Sensitive Configuration</h3>
<p>So far, we have been embedding values directly in configuration files. Let's try to make our setup a bit more secure by encrypting values before they are added to our repository. In the <code>bootstrap.properties</code> file add the following settings:</p>
<pre lang="properties"><code>encrypt.key-store.location=file:///etc/cas/casconfigserver.jks
encrypt.key-store.password=changeit
encrypt.key-store.alias=cas
encrypt.key-store.secret=changeit
</code></pre>
<p>You will, of course, need to create the above keystore using <code>keytool</code>:</p>
<pre lang="bash"><code>keytool -genkeypair -alias cas -keyalg RSA \
  -dname "CN=CAS,OU=Unit,O=Organization,L=City,S=State,C=US" \
  -keypass changeit -keystore /etc/cas/casconfigserver.jks -storepass changeit
</code></pre>
<p>The keystore above is what controls the semantics of encryption/decryption of settings. The encryption is done with the public key, and a private key is needed for decryption.</p>
<p>As a test, I am going to ask the Config server to encrypt the text <code>casuser::QASomething</code> for me:</p>
<pre lang="bash"><code>curl -k -u casuser:Mellon https://config.example.org:8888/casconfigserver/encrypt -d casuser::QASomething
</code></pre>
<p>If you take the encrypted value and simply try to decrypt it you should see the original:</p>
<pre lang="bash"><code>curl -k -u casuser:Mellon https://config.example.org:8888/casconfigserver/encrypt -d $ENCRYPTED_VALUE
</code></pre>
<p>Once the value is encrypted, it can be put back into the <code>cas-qa.properties</code> configuration file:</p>
<pre lang="properties"><code>cas.authn.accept.users={cipher}$ENCRYPTED_VALUE
</code></pre>
<p>If you ask the Config server for the <code>qa</code> profile of the <code>cas</code> application, you should see the <em>decrypted value</em> in the results:</p>
<pre lang="bash"><code>curl -k -u casuser:Mellon https://config.example.org:8888/casconfigserver/cas/qa | jq
</code></pre>
<p>That's it for now. Let's move onto the CAS server configuration and let it fetch settings from the Config server.</p>
<h2>
<a id="cas-server-configuration" class="anchor" href="#cas-server-configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>CAS Server Configuration</h2>
<p>The task at hand is to describe the Spring Cloud Config server to the CAS server so it can begin to configure itself via provided settings. To do so, you want to start with the <a href="https://github.com/apereo/cas-overlay-template">CAS Overlay</a>, clone the project and then put the following settings into a <code>src/main/resources/bootstrap.properties</code> file:</p>
<pre lang="properties"><code>spring.application.name=cas

spring.profiles.active=default

spring.cloud.config.uri=https://casuser:Mellon@config.example.org:8888/casconfigserver
spring.cloud.config.profile=qa
spring.cloud.config.label=master

spring.cloud.config.enabled=true

spring.cloud.config.watch.enabled=true
spring.cloud.config.watch.initialDelay=30000
spring.cloud.config.watch.delay=1000

spring.cloud.config.fail-fast=true
health.config.enabled=true
</code></pre>
<p>In summary, we have the Spring Cloud config enabled with a location to the Config server. Next, we teach CAS to activate the <code>qa</code> profile when it asks for configuration settings, and we switch the CAS server application profile to <code>default</code> to disable the standalone strategy of locating settings. As for the other settings, hold onto them right now and we'll review them in just a bit.</p>
<p>The <code>label</code> setting is useful for rolling back to previous versions of configuration; with the default Config Server implementation it can be a git label, branch name or commit id. A label can also be provided as a comma-separated list, in which case the items in the list are tried one-by-one until one succeeds. This can be useful when working on a feature branch, for instance, when you might want to align the config label with your branch, but make it optional.</p>
<p>So at this point, our expectation is that CAS will load its own <code>application.properties</code> file by default which has a bunch of settings that for instance deal with SSL, keystores, ports, etc. Then we expect CAS to load any and all settings from the Spring Cloud config server that are associated with <code>cas</code> and <code>qa</code> where these settings should override anything that CAS by default handles and provides. This means that when it's all said and done, our CAS server should be running on port <code>8555</code> (as opposed to the default <code>8443</code>) and the static credentials used to authenticate users should include the username/password <code>casuser</code> and <code>QASomething</code> (as opposed to the default <code>casuser</code> and <code>Mellon</code>).</p>
<p>Right?</p>
<p>If you have followed the story so far, crank up the your CAS server deployment and examine the above scenario. Works as advertised, doesn't it?!</p>
<h3>
<a id="refresh--reload" class="anchor" href="#refresh--reload" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Refresh &amp; Reload</h3>
<p>The CAS spring cloud configuration server is constantly monitoring changes to the underlying property sources automatically but has no way to broadcast those changes to its own clients, such as the CAS server itself. Therefore, in order to broadcast such change events, CAS presents various endpoints that allow the user to <a href="https://apereo.github.io/cas/development/configuration/Configuration-Management-Reload.html">refresh the configuration</a> as needed. This means that an adopter would simply change a required CAS setting and then would submit a request to CAS to <em>refresh</em> its current state. At runtime! All CAS internal components that are affected by the external change are quietly reloaded and the setting takes immediate effect, completely removing the need for container restarts or CAS re-deployments.</p>
<p>In order to handle automatic updates to CAS settings from the Spring Cloud Config server, we can try the following:</p>
<p>First, we are going to switch the CAS server to activate the <code>dev</code> profile (instead of the current <code>qa</code>) when querying for settings in the <code>bootstrap.properties</code> file:</p>
<pre lang="properties"><code>spring.cloud.config.profile=dev
</code></pre>
<p>Then, we are going to modify and commit the <code>cas-dev.properties</code> file of the Spring Cloud Config server in our Git repository to enable CAS actuator endpoints by default which will allow us to invoke the <code>actuator/refresh</code> endpoint provided by Spring Boot:</p>
<pre lang="properties"><code>management.endpoints.web.exposure.include=*
management.endpoints.enabled-by-default=true
cas.monitor.endpoints.endpoint.defaults.access=AUTHENTICATED
spring.security.user.name=casuser
spring.security.user.password=Mellon
</code></pre>
<!-- raw HTML omitted -->
<p>Once the changes are committed, we can switch back to the CAS server and re-run it one more time for it to pick up the <code>dev</code> profile settings and give us access to the relevant endpoints. When the CAS server is up, try invoking the <code>refresh</code> endpoint of the CAS server:</p>
<pre lang="bash"><code>curl -k -u casuser:Mellon https://sso.example.org:8555/cas/actuator/refresh -d {} -H "Content-Type: application/json"
</code></pre>
<p>Watch the CAS server logs where you see something like:</p>
<pre><code>INFO [...CasConfigurationEventListener] - &lt;Refreshing CAS configuration. Stand by...&gt;
</code></pre>
<p>Let's change something then. Switch over to the <code>cas-dev.properties</code> file of the Spring Cloud Config server and change and commit the following setting:</p>
<pre lang="properties"><code>cas.authn.accept.users=casuser::Developers
</code></pre>
<p>Once the change is committed, invoke the refresh endpoint again just as before and observe the output:</p>
<pre lang="json"><code>["config.client.version","cas.authn.accept.users"]
</code></pre>
<p>At this point, we should be able to pull up the CAS server in the browser and log in using <code>casuser</code> and <code>Developers</code> as credentials. Right? Give it a shot. Works as advertised, doesn't it?!</p>
<!-- raw HTML omitted -->
<p>This is very handy. You can make a change to a given application and profile in a centralized configuration server and simply invoke the client, that is the CAS server to refresh itself. Imagine the possibilities with distributed development and configuration management!</p>
<h3>
<a id="what-about" class="anchor" href="#what-about" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>What About...</h3>
<p>There a few things that we have yet to address that would be outside the scope of this document. Here they are:</p>
<h4>
<a id="spring-cloud-config-bus" class="anchor" href="#spring-cloud-config-bus" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Spring Cloud Config Bus</h4>
<p>If we have more than one CAS server we need to invoke the <code>refresh</code> endpoint for each and every single server node for it to refresh itself and pick up changes. To solve this problem, we can use Spring Cloud Bus. The bus acts as the communication channel across all CAS server nodes and can be backed via RabbitMQ, Kafka, Redis, etc. Each CAS server will be connected to the bus and gains a special endpoint called <code>bus-refresh</code>. Calling this endpoint will cause the receiving node to:</p>
<ul>
<li>Get the latest configuration from the config server and update its configuration annotated by <code>@RefreshScope</code>
</li>
<li>Send a message to the bus informing about refresh event</li>
<li>All subscribed CAS nodes will update their configuration as well</li>
</ul>
<h4>
<a id="spring-cloud-config-monitor" class="anchor" href="#spring-cloud-config-monitor" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Spring Cloud Config Monitor</h4>
<p>How does the Spring Cloud Config server detect changes from property sources? Could we make that process automatic, and have it broadcast a notification to CAS server nodes? This is where the Spring Cloud Config Monitor comes in handy. Similar to the above, the Config server can take advantage of this monitor that may be backed by a bus via AMQP. As changes are detected, they are broadcasted via events on the bus for the receiving CAS nodes to recognize and update themselves automatically, without manual refresh invocations.</p>
<h2>
<a id="final-thoughts" class="anchor" href="#final-thoughts" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Final Thoughts</h2>
<p>So, as you can observe there is quite a lot involved here to make for a cloud-ready distributed configuration management system. For many CAS deployments, this might seem overkill as most simply just rely on a standalone type of deployment where there is only a couple of CAS server nodes each feeding off of a simple <code>cas.properties</code> file adjacent to the node itself. It is true that the setting up CAS in the cloud using the described strategies in this post can take quite a bit of time and expertise. Thus, evaluate options carefully before jumping into coolness. If you have a strategic vision of managing configuration in distributed cloud-ready fashion, this is a good long-term investment. If you are thinking about centralizing application configuration across your entire institution and manage the configuration in a distributed and real-time fashion, it's worth it to go through the setup. If you have use cases that require configuration changes in real-time without downtime and restarts in a distributed environment, it makes sense to explore such options. Otherwise, you may find the pain and the cons outweigh the pros.</p>
<h2>
<a id="finale" class="anchor" href="#finale" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Finale</h2>
<p>I hope this review was of some help to you and I am sure that both this post as well as the functionality it attempts to explain can be improved in any number of ways. Please feel free to <a href="https://apereo.github.io/cas/developer/Contributor-Guidelines.html">engage and contribute</a> as best as you can.</p>
<p><a href="https://fawnoos.com">Misagh Moayyed</a></p>